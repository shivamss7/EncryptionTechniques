"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.encrypt = encrypt;
exports.decrypt = decrypt;

var _params = _interopRequireDefault(require("./params.js"));

/**
 * nodeapi.js
 */

/**
 * Encrypt plaintext message via AES Node.js crypto API
 * @param {Uint8Array} msg - Plaintext message to be encrypted.
 * @param {Uint8Array} key - Byte array of symmetric key.
 * @param {String} name - Name of AES algorithm like 'AES-GCM'.
 * @param {Uint8Array} [iv] - Byte array of initial vector if required.
 * @param {Uint8Array} [additionalData] - Byte array of additional data if required.
 * @param {Number} [tagLength] - Authentication tag length if required.
 * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.
 * @return {Uint8Array} - Encrypted message byte array.
 * @throws {Error} - Throws error if UnsupportedCipher.
 */
function encrypt(msg, key, _ref, nodeCrypto) {
  var name = _ref.name,
      iv = _ref.iv,
      additionalData = _ref.additionalData,
      tagLength = _ref.tagLength;
  var alg = _params.default.ciphers[name].nodePrefix;
  alg = "".concat(alg, "-").concat((key.byteLength * 8).toString(), "-");
  alg = alg + _params.default.ciphers[name].nodeSuffix;
  var cipher;

  switch (name) {
    case 'AES-GCM':
      {
        cipher = nodeCrypto.createCipheriv(alg, key, iv, {
          authTagLength: tagLength
        });
        cipher.setAAD(additionalData);
        break;
      }

    case 'AES-CBC':
      {
        cipher = nodeCrypto.createCipheriv(alg, key, iv);
        break;
      }
  }

  var body = new Uint8Array(cipher.update(msg));
  var final = new Uint8Array(cipher.final());
  var tag = new Uint8Array([]);
  if (name === 'AES-GCM') tag = new Uint8Array(cipher.getAuthTag());
  var data = new Uint8Array(body.length + final.length + tag.length);
  data.set(body);
  data.set(final, body.length);
  data.set(tag, body.length + final.length);
  return data;
}
/**
 * Decrypt data through AES Node.js crypto API.
 * @param {Uint8Array} data - Encrypted message to be decrypted.
 * @param {Uint8Array} key - Byte array of symmetric key.
 * @param {String} name - Name of AES algorithm like 'AES-GCM'.
 * @param {Uint8Array} [iv] - Byte array of initial vector if required.
 * @param {Uint8Array} [additionalData] - Byte array of additional data if required.
 * @param {Number} [tagLength] - Authentication tag length if required.
 * @param {Object} nodeCrypto - NodeCrypto object, i.e., require(crypto) in Node.js.
 * @return {Uint8Array} - Decrypted message byte array.
 * @throws {Error} - Throws error if UnsupportedCipher or DecryptionFailure.
 */


function decrypt(data, key, _ref2, nodeCrypto) {
  var name = _ref2.name,
      iv = _ref2.iv,
      additionalData = _ref2.additionalData,
      tagLength = _ref2.tagLength;
  var alg = _params.default.ciphers[name].nodePrefix;
  alg = "".concat(alg, "-").concat((key.byteLength * 8).toString(), "-");
  alg = alg + _params.default.ciphers[name].nodeSuffix;
  var decipher;
  var body;

  switch (name) {
    case 'AES-GCM':
      {
        decipher = nodeCrypto.createDecipheriv(alg, key, iv, {
          authTagLength: tagLength
        });
        decipher.setAAD(additionalData);
        body = data.slice(0, data.length - tagLength);
        var tag = data.slice(data.length - tagLength);
        decipher.setAuthTag(tag);
        break;
      }

    case 'AES-CBC':
      {
        decipher = nodeCrypto.createDecipheriv(alg, key, iv);
        body = data;
        break;
      }

    default:
      throw new Error('UnsupportedCipher');
  }

  var decryptedBody = decipher.update(body);
  var final;

  try {
    final = decipher.final();
  } catch (e) {
    throw new Error('DecryptionFailure');
  }

  var msg = new Uint8Array(final.length + decryptedBody.length);
  msg.set(decryptedBody);
  msg.set(final, decryptedBody.length);
  return msg;
}